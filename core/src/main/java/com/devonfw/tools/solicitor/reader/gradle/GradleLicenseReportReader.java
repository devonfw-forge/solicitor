/**
 * SPDX-License-Identifier: Apache-2.0
 */

package com.devonfw.tools.solicitor.reader.gradle;

import com.devonfw.tools.solicitor.common.PackageURLHelper;
import com.devonfw.tools.solicitor.common.SolicitorRuntimeException;
import com.devonfw.tools.solicitor.model.inventory.ApplicationComponent;
import com.devonfw.tools.solicitor.model.masterdata.Application;
import com.devonfw.tools.solicitor.model.masterdata.UsagePattern;
import com.devonfw.tools.solicitor.reader.AbstractReader;
import com.devonfw.tools.solicitor.reader.Reader;
import com.devonfw.tools.solicitor.reader.gradle.model.Dependency;
import com.devonfw.tools.solicitor.reader.gradle.model.License;
import com.devonfw.tools.solicitor.reader.gradle.model.LicenseSummary;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import org.drools.mvel.accessors.BaseDateClassFieldReader;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.*;

/**
 * A {@link Reader} which reads data generated by the
 * <a href="https://github.com/jk1/Gradle-License-Report">Gradle License Report Plugin</a>.
 */
@Component
public class GradleLicenseReportReader extends AbstractReader implements Reader {

  /**
   * The supported type of this {@link Reader}.
   */
  public static final String SUPPORTED_TYPE = "gradle-license-report-json";

  /** {@inheritDoc} */
  @Override
  public Set<String> getSupportedTypes() {

    return Collections.singleton(SUPPORTED_TYPE);
  }

  /** {@inheritDoc} */
  @Override
  public void readInventory(String type, String sourceUrl, Application application, UsagePattern usagePattern,
      String repoType, String packageType, Map<String, String> configuration) {

    int components = 0;
    int licenses = 0;


    // According to tutorial https://github.com/FasterXML/jackson-databind/
    ObjectMapper mapper = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);
    try {
      Map<String, List> report = mapper.readValue(this.inputStreamFactory.createInputStreamFor(sourceUrl), Map.class);
      List<Map<String, String>> dependencies = report.get("dependencies");

      for (Map<String, String> dependency: dependencies) {
        String[] dependencyParts = dependency.get("moduleName").split(":");
        if (dependencyParts.length != 2) {
          throw new SolicitorRuntimeException(
                  "Could not extract groupId, artifactId from moduleName: '" + dependency.get("moduleName") + "'");
        }

        ApplicationComponent appComponent = getModelFactory().newApplicationComponent();
        appComponent.setApplication(application);
        appComponent.setGroupId(dependencyParts[0]);
        appComponent.setArtifactId(dependencyParts[1]);
        appComponent.setVersion(dependency.get("moduleVersion"));
        appComponent.setOssHomepage(dependency.get("moduleUrl"));
        appComponent.setUsagePattern(usagePattern);
        appComponent.setRepoType(repoType);
        appComponent.setPackageUrl(
                PackageURLHelper.fromMavenCoordinates(dependencyParts[0], dependencyParts[1], dependency.get("moduleVersion")).toString());
        addRawLicense(appComponent, dependency.get("moduleLicense"), dependency.get("moduleLicenseUrl"), sourceUrl);

        components++;
        licenses++;
      }

      doLogging(sourceUrl, application, components, licenses);

    } catch (IOException e) {
      throw new SolicitorRuntimeException("Could not read Gradle License Report inventory source '" + sourceUrl + "'", e);
    }
  }

}
